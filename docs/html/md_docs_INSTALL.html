<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Bluenet: Installation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Installation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a step-by-step instruction to install the bluenet build system. If you prefer a simple install script, you can use the <code>install.sh</code> script provided in the <a href="https://github.com/crownstone/crownstone-sdk#bluenet_lib_configs">crownstone-sdk</a> repository.</p>
<p>The installation has been tested on Ubuntu 14.04 and assumes you use the J-Link Lite CortexM-9 programmer.</p>
<h2>Prerequisites</h2>
<p>To compile and run the bluenet firmware, the following prerequisites are needed:</p>
<ol type="1">
<li>Nordic SDK</li>
<li>Cross-compiler for ARM</li>
<li>JLink utilities from Segger</li>
</ol>
<h3>Nordic SDK</h3>
<p>IMPORTANT NOTE: THIS VERSION OF BLUENET IS ONLY COMPATIBLE WITH THE NEWER CHIP NRF52. USE THE OLDER BRANCH SDK_8 FOR THE NRF51 CHIPS!</p>
<p>Download Nordic's SDK and unzip:</p>
<ul>
<li><a href="https://developer.nordicsemi.com/nRF5_SDK/nRF5_SDK_v11.x.x/">Nordic nRF5 SDK 11</a></li>
</ul>
<p>By default, we use the Softdevices provided in the Nordic SDK. For SDK 11, this is the <a href="https://www.nordicsemi.com/eng/Products/S132-SoftDevice">Nordic S132 Softdevice 2.0</a>, so you don't need to download any softdevices separately. However, if you want to use a different Softdevice version, you can download it and later adapt the config to use the new softdevice.</p>
<p>There is a bug in Nordic's SDK code, search for files named <code>nrf_svc.h</code>. In those files, replace the assembly line: </p><pre class="fragment">#define GCC_CAST_CPP (uint8_t)
</pre><p>With: </p><pre class="fragment">#define GCC_CAST_CPP (uint16_t)
</pre><p>You can do that manually, or use </p><pre class="fragment">perl -p -i -e 's/#define GCC_CAST_CPP \(uint8_t\)/#define GCC_CAST_CPP \(uint16_t\)/g' `grep -ril "#define GCC_CAST_CPP (uint8_t)" *`
</pre><p>from the root folder of the Nordic SDK to do it for you.</p>
<h3>J-Link</h3>
<p>Download and install J-Link Seggerâ€™s <a href="http://www.segger.com/jlink-software.html">software</a>. The current version is 5.12.8 <a href="https://www.segger.com/downloads/jlink/jlink_5.12.8_x86_64.deb">64bit .deb file version 5.12.8</a></p>
<p>Then install it: </p><pre class="fragment">sudo dpkg -i jlink_5.12.8_x86_64.deb
</pre><h3>Cross compiler</h3>
<p>A cross-compiler for ARM is the GCC cross-compiler which is maintained by the ARM folks on <a href="https://launchpad.net/gcc-arm-embedded">Launchpad</a>.</p>
<p>Download and extract version <a href="https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q2-update/+download/gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2">2016-q2</a>.</p>
<p>Assuming you have a 64bit system, you will have to install some 32bit packages: </p><pre class="fragment">sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get install libstdc++6:i386 libncurses5:i386
</pre><p>If the cross-compiler does not work, make sure you check if all its dependencies are met: </p><pre class="fragment">ldd /opt/gcc-arm-none-eabi-5_4-2016q2/bin/arm-none-eabi-gcc
</pre><h3>Misc.</h3>
<p>Bluenet uses a cmake build system, so you will need it: </p><pre class="fragment">sudo apt-get install cmake
</pre><h2>Getting the Bluenet code</h2>
<p>The best way is to first <a href="https://github.com/dobots/bluenet/fork">fork</a> the bluenet repository. Then create a workspace folder where all the necessary files and folders will be stored, e.g. </p><pre class="fragment">mkdir ~/bluenet-workspace
</pre><p>and download the code (We recommend to download the code into the workspace, but you can place it anywhere you want): </p><pre class="fragment">cd ~/bluenet-workspace
git clone https://github.com/YOUR_GITHUB_USERNAME/bluenet
</pre><p>and set the correct upstream: </p><pre class="fragment">cd bluenet
git remote add upstream git@github.com:crownstone/bluenet.git
</pre><p>Next make a dir for your config file(s), by default, this should be called <code>config</code> and be placed inside the workspace. </p><pre class="fragment">mkdir ~/bluenet-workspace/config
</pre><p>Now we need to set up the environment variables to keep track of the different folders required to build bluenet </p><pre class="fragment">cd ~/bluenet_workspace/bluenet
cp env.config.template env.config
</pre><p>Open the file then uncomment and assign the variable <code>BLUENET_WORKSPACE_DIR</code> to your workspace path, e.g. </p><pre class="fragment">BLUENET_WORKSPACE_DIR=~/bluenet_workspace
</pre><p>If you placed the bluenet source code at a different place than <code>$BLUENET_WORKSPACE_DIR/bluenet</code>, then you can also uncomment and assign the <code>BLUENET_DIR</code> variable to the correct location. Same for the config directory, if you choose a different location than <code>$BLUENET_WORKSPACE_DIR/config</code>, assign the <code>BLUENET_CONFIG_DIR</code> to point to the correct location.</p>
<p>Last we want to load the environments by default for every terminal session with the following command: </p><pre class="fragment">echo "source ~/bluenet_workspace/bluenet/scripts/env.sh" &gt;&gt; ~/.bashrc
</pre><p>Apply the environment variables: </p><pre class="fragment">source ~/.bashrc
</pre><h2>Configuration</h2>
<p>Copy the template config file to your config directory: </p><pre class="fragment">cp $BLUENET_DIR/CMakeBuild.config.template $BLUENET_CONFIG_DIR/CMakeBuild.config
</pre><p>then open it to customize </p><pre class="fragment">gedit $BLUENET_CONFIG_DIR/CMakeBuild.config &amp;
</pre><p>The following variables have to be set before you can build the code:</p>
<ul>
<li>Set <code>BLUETOOTH_NAME</code> to something you like, but make sure it's short (&lt;9).</li>
<li>Set <code>HARDWARE_BOARD</code> to the board you're using. This determines the pin layout.</li>
<li>Set <code>COMPILER_PATH</code> to the path where the compiler can be found (it should contain the <code>/bin</code> subdir).</li>
<li>Set <code>NRF51822_DIR</code> to wherever you installed the Nordic SDK. It should have the following subdirectories:<ul>
<li>components</li>
<li>documentation</li>
<li>examples</li>
<li>external</li>
<li>SVD</li>
</ul>
</li>
</ul>
<p>Last, copy any lines that you want to adjust over from the default configuration.</p>
<p>E.g.</p>
<ul>
<li>enable meshing by setting <code>MESHING=1</code></li>
<li>enable device scanner by setting <code>INTERVAL_SCANNER_ENABLED=1</code></li>
<li>enable the power service by setting <code>POWER_SERVICE=1</code></li>
<li>set serial verbosity to debug by setting <code>SERIAL_VERBOSITY=DEBUG</code></li>
</ul>
<h3>Advanced Configuration</h3>
<p>If you have problems with the path of the JLink tool, you can adjust the paths of the JLinkExe and JLinkGdbServer:</p>
<ul>
<li>Set <code>JLINK</code> to the correct JLink Exe file. (Default: <code>/usr/bin/JLinkExe</code>)</li>
<li>Set <code>JLINK_GDB_SERVER</code> to the correct file. (Default: <code>/usr/bin/JLinkGDBServer</code>)</li>
</ul>
<p>If you installed a different compiler than the one we recommended above, adjust the compiler type:</p>
<ul>
<li>Set <code>COMPILER_TYPE</code> to the correct compiler type (Default: <code>arm-none-eabi</code>)</li>
</ul>
<p>If you want to download and use a different softdevice, you will need to adjust the values above:</p>
<ul>
<li>Set <code>SOFTDEVICE</code> (basename of file without <code>_softdevice.hex</code>)</li>
<li>Set <code>SOFTDEVICE_SERIES</code>, <code>SOFTDEVICE_MAJOR</code>, and <code>SOFTDEVICE_MINOR</code> accordingly.</li>
<li>Set <code>APPLICATION_START_ADDRESS</code>, <code>APPLICATION_LENGTH</code>, <code>RAM_R1_BASE</code> and <code>RAM_APPLICATION_AMOUNT</code> to the correct values (can be found in the Softdevice Specification Document)</li>
</ul>
<p>And set the following variables to the correct paths:</p>
<ul>
<li>Set <code>SOFTDEVICE_DIR</code> to wherever you unzipped the SoftDevice dir from Nordic.</li>
<li>Set <code>SOFTDEVICE_DIR_API</code> to the directory with the SoftDevice include dir. This is relative, <code>${SOFTDEVICE_DIR}/${SOFTDEVICE_DIR_API}/</code> will be the used path.</li>
<li>Set <code>SOFTDEVICE_DIR_HEX</code> to the directory with the SoftDevice .hex file. This is relative, <code>${SOFTDEVICE_DIR}/${SOFTDEVICE_DIR_HEX}/</code> will be the used path. (use <code>/</code> if the .hex file is in the same folder as <code>SOFTDEVICE_DIR</code>)</li>
<li>If you run into memory issues, you can play around with <code>HEAP_SIZE</code>. Increasing the heap size (dynamic memory), will reduce the stack size (static memory).</li>
</ul>
<h2>Usage</h2>
<p>Once everything is installed and configured, the code can be compiled and uploaded. You will have to attach a programmer/debugger, like the JLink. Towards that you only need four pins: <code>GND</code>, <code>3V</code>, <code>SWDIO / RESET</code>, and <code>SWCLK / FACTORY</code>. The pin layout of the JLink connector is written out on the <a href="http://dobots.nl/2014/03/05/rfduino-without-rfduino-code/">DoBots blog</a>.</p>
<h3>Compiling, uploading and debugging</h3>
<p>First build and upload the SoftDevice: </p><pre class="fragment">cd $BLUENET_DIR/scripts
./softdevice.sh build
./softdevice.sh upload
</pre><p>Now we can build our own software: </p><pre class="fragment">cd $BLUENET_DIR/scripts
./firmware.sh build
</pre><p>By default, the code is built inside the <code>$BLUENET_WORKSPACE_DIR/build</code> folder and if successful, the compiled binaries (*.hex, *.elf, *.bin) are copied to <code>$BLUENET_WORKSPACE_DIR/bin</code>. If you want to change either folder, you can uncomment and assign the following environment variables in <code>$BLUENET_DIR/env.config</code> </p><pre class="fragment">- `BLUENET_BUILD_DIR`. Set this variable to the path where the build files should be stored.
- `BLUENET_BIN_DIR`. Set this variable to the path where the compiled binaries should be stored
</pre><p>If the compilation fails due to misconfiguration, you might have to remove the build dir and then try again.</p>
<p>To upload the application with the JLink you can use: </p><pre class="fragment">./firmware.sh upload
</pre><p>To debug with <code>gdb</code> you can use: </p><pre class="fragment">./firmware.sh debug
</pre><p>There is a shortcut to build and upload you can use: </p><pre class="fragment">./firmware.sh run
</pre><p>And another shortcut to build, upload, and debug: </p><pre class="fragment">./firmware.sh all
</pre><h3>Advanced Usage</h3>
<p>The above scripts and configuration is sufficient if you work with one device and one configuration file. However, if you want to quickly switch between different configurations or have more than one device connected, you might want to try out the support for multiple targets.</p>
<h4>Local config file</h4>
<p>There are options which are the same for all configurations, such as the paths (<code>NRF51822_DIR</code>, <code>COMPILER_PATH</code>, etc.). Instead of defining them in every configuration file, you can create a file <code>$BLUENET_DIR/CMakeBuild.config.local</code> and store common configuration values there. This file is optional and not required. If it is available, it will overwrite the default values from $BLUENET_DIR/CMakeBuild.config.default`. The order of precedence of the configuration values in the 3 files is as follows:</p>
<ol type="1">
<li>Values are loaded from <code>$BLUENET_DIR/CMakeBuild.config.default</code></li>
<li>Values are loaded from <code>$BLUENET_DIR/CMakeBuild.config.local</code>. This file is only read if it is present. It overwrites the values loaded at step 1.</li>
<li>Values are loaded from <code>$BLUENET_CONFIG_DIR/CMakeBuild.config</code>. Values read here will overwrite values loaded at step 1 and 2.</li>
</ol>
<h4>Different Configurations</h4>
<p>If you quickly want to switch between different configurations, you can create sub folders in the <code>$BLUENET_CONFIG_DIR</code> with different names. E.g. let's create two additional config files, one called BLUE and one called RED (We call these henceforth targets, eg. target BLUE and target RED). You can create two subdirectories</p>
<ul>
<li><code>$BLUENET_CONFIG_DIR/BLUE</code></li>
<li><code>$BLUENET_CONFIG_DIR/RED</code></li>
</ul>
<p>Then create in each subdirectory a file called CMakeBuild.config (or copy it over from an existing file, the template or the default).</p>
<p>The new structure in the <code>$BLUENET_CONFIG_DIR</code> would now be:</p>
<ul>
<li><code>$BLUENET_CONFIG_DIR</code><ul>
<li><code>BLUE</code><ul>
<li><code>CMakeBuild.config</code></li>
</ul>
</li>
<li><code>RED</code><ul>
<li><code>CMakeBuild.config</code></li>
</ul>
</li>
<li><code>CMakeBuild.config</code></li>
</ul>
</li>
</ul>
<p>Last, execute the following command to enable multi target / configurations: </p><pre class="fragment">cp $BLUENET_DIR/scripts/_targets_template.sh $BLUENET_CONFIG_DIR/_targets.sh
</pre><p>Now you can call the scripts above together with the target at the end of the call.</p>
<p>E.g. to build and upload target <code>BLUE</code> execute: </p><pre class="fragment">./firmware.sh run BLUE
</pre><p>and to build, upload and debug target <code>RED</code> call: </p><pre class="fragment">./firmware.sh all RED
</pre><p>The following scripts support multi targets:</p>
<ul>
<li><code>firmware.sh</code>. Usage <code>./firmware.sh &lt;COMMAND&gt; &lt;TARGET&gt;</code></li>
<li><code>softdevice.sh</code>. Usage <code>./softdevice.sh &lt;COMMAND&gt; &lt;TARGET&gt;</code></li>
<li><code>hardware_version.sh</code>. Usage <code>./hardware_version.sh &lt;TARGET&gt;</code></li>
<li>'all.sh'. Usage <code>./all.sh &lt;TARGET&gt;</code></li>
</ul>
<h3>Different Devices</h3>
<p>To take the case of the different configurations a bit further, we can also assign the different configurations to different devices. E.g. if you are using 2 PCA10000 boards, each one has a different serial number. If you try to upload firmware to one of the devices, while having both plugged in, JLink will return with an error because it doesn't know to which device to upload the firmware. To solve this issue, follow the steps aboth to create two new configurations. (target <code>BLUE</code> and target <code>RED</code>)</p>
<p>After completing the steps above, open the file <code>$BLUENET_CONFIG_DIR/_targets.sh</code> and between the lines </p><pre class="fragment">case "$target" in
...
esac
</pre><p>add your new targets as </p><pre class="fragment">BLUE)
  serial_num=&lt;SERIAL NUMBER DEVICE1&gt;
  ;;
RED)
  serial_num=&lt;SERIAL NUMBER DEVICE2&gt;
  ;;
</pre><p>Note: It's also a good practice to define one of the devices as the default, which will be used if no target is supplied to the scripts, or if you want to add different configurations, without adding a new entry every time. So let's say the device with the configuration <code>RED</code> is the default, the code above will be adapted to </p><pre class="fragment">BLUE)
  serial_num=&lt;SERIAL NUMBER DEVICE1&gt;
  ;;
RED)
*)
  serial_num=&lt;SERIAL NUMBER DEVICE2&gt;
  ;;
</pre><p>To obtain the serial number of the JLink devices, run </p><pre class="fragment">JLinkExe
</pre><p>and then enter <code>ShowEmuList</code>, which gives a list of connected devices, e.g. </p><pre class="fragment">JLink&gt; ShowEmuList
J-Link[0]: Connection: USB, Serial number: 680565191, ProductName: J-Link OB-SAM3U128-V2-NordicSem
J-Link[1]: Connection: USB, Serial number: 518005793, ProductName: J-Link Lite Cortex-M-9
JLink&gt;
</pre><p>Now if you call one of the scripts, with target <code>BLUE</code>, e.g. <code>./firmware.sh run BLUE</code> it will compile config <code>BLUE</code> at <code>$BLUENET_CONFIG_DIR/BLUE/CMakeBuild.config</code> and upload it to <code>DEVICE1</code>. While calling <code>./firmware.sh run RED</code> will compile config <code>RED</code> at <code>$BLUENET_CONFIG_DIR/RED/CMakeBuild.config</code> and upload it to <code>DEVICE2</code>.</p>
<p>And if you call <code>./firmware.sh run</code> it will compile the default config at <code>$BLUENET_CONFIG_DIR/CMakeBuild.config</code> and upload it to device <code>DEVICE2</code>.</p>
<h2>Flashing with the ST-Link</h2>
<p>The above assumes you have the J-Link programmer from Nordic. If you do not have that device, you can still program something like the RFduino or the <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration. ">Crownstone</a>, by using an ST-Link. A full explanation can be found on <a href="https://dobots.nl/2015/01/23/programming-the-nrf51822-with-the-st-link/">https://dobots.nl/2015/01/23/programming-the-nrf51822-with-the-st-link/</a>.</p>
<p>Disclaimer: no work has been done on the ST-Link scripts for quite some time, so things might not work anymore.</p>
<h3>Combine softdevice and firmware</h3>
<p>First of all you should combine all the required binaries into one big binary. This is done by the script combine.sh. Before you use it, you will need to install srec_cat on your system. </p><pre class="fragment">sudo apt-get install srecord
</pre><p>If you call the script it basically just runs srec_cat: </p><pre class="fragment">./combine.sh
</pre><p>And you will see that it runs something like this: </p><pre class="fragment">srec_cat /opt/softdevices/s110_nrf51822_7.0.0_softdevice.hex -intel crownstone.bin -binary -offset 0x00016000 -o combined.hex -intel
</pre><p>You have to adjust that file on the moment manually to switch between softdevices or to add/remove the bootloader, sorry! Note that the result is a <code>.hex</code> file. Such a file does haveinformation across multiple memory sections. If you upload a <code>.bin</code> file often configuration bits/bytes will not be set!</p>
<h3>Upload with OpenOCD</h3>
<p>Rather than downloading <code>openocd</code> from the Ubuntu repositories, it is recommended to get the newest software from the source: </p><pre class="fragment">cd /opt
git clone https://github.com/ntfreak/openocd
sudo aptitude install libtool automake libusb-1.0-0-dev expect
cd openocd
./bootstrap
./configure --enable-stlink
make
sudo make install
</pre><p>Also, make sure you can use the USB ST-Link device without sudo rights: </p><pre class="fragment">sudo cp scripts/openocd/49-stlinkv2.rules /etc/udev/rules.d
sudo restart udev
</pre><p>You can now use the <code>flash_openocd.sh</code> script in the <code>scripts</code> directory: </p><pre class="fragment">./flash_openocd.sh init
</pre><p>And in another console: </p><pre class="fragment">./flash_openocd.sh upload combined.bin
</pre><p>Here the binary <code>combined.bin</code> is the softdevice and application combined.</p>
<h2>UART</h2>
<p>The main way to debug your application is through UART. The TX pin is defined by the board type you configured (<code>HARDWARE_BOARD</code>), for each board type the TX pin nr can be found in the <code><a class="el" href="cs__Boards_8h_source.html">include/cfg/cs_Boards.h</a></code> file.</p>
<p>In case you happen to have the nRFgo Motherboard (nRF6310, strongly recommended) you can easily connect the pins at P2.0 and P2.1 to respectively the pins RXD and TXD on P15 on the board. Do not forget to switch on the RS232 switch. Subsequently you will need some RS232 to USB cable if you haven't an extremely old laptop.</p>
<p>The current set baudrate you can find in <code>cs_Serial.cpp</code> and is <code>38400</code> baud. To read from serial you can for example use <code>minicom</code> (replace ttyUSB0 with the correct device): </p><pre class="fragment">minicom -b 38400 -c on -D /dev/ttyUSB0
</pre><p>If this requires sudo rights, you may want to add yourself to the dialout group: </p><pre class="fragment">sudo adduser $USER dialout
</pre><p>You will have to logout and login for it to have effect.</p>
<p>If all goes well, you should see text appearing whenever the crownstone is rebooted/reset. This also shows you which services and characteristics are enabled.</p>
<p>The verbosity of the debug ouptut can be set in the CMakeBuild.conifg through the variable <code>SERIAL_VERBOSITY</code>. Highest level is <code>DEBUG</code>, lowest level is <code>FATAL</code>. If you want to disable logging totally, set verbosity to <code>NONE</code>.</p>
<p>For verbosity level <code>DEBUG</code>, you can add even more verbosity per class files by enabling the flags in <code>/include/cfg/cs_Debug.h</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
